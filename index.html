<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etamax 2026 | Nakshatra 2026 - Coming Soon</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@300;400;600&display=swap');

        :root {
            --primary-glow: #00ffcc;
            --secondary-glow: #bd00ff;
            --bg-deep: #050510;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-deep);
            font-family: 'Inter', sans-serif;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Hyperspace Canvas */
        #hyperspaceCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            /* Ensure it is visible above body background */
        }

        /* Glassmorphism Card (Kept from previous design) */
        .container {
            position: relative;
            z-index: 10;
            /* Higher z-index to float above canvas */
            padding: 3rem 4rem;
            background: rgba(30, 30, 35, 0.6);
            /* Greyish/Dark Glass Effect */
            border-radius: 20px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            text-align: center;
            overflow: hidden;
            max-width: 90%;
            width: 600px;
        }

        /* Decorative Glows */
        .glow {
            position: absolute;
            width: 150px;
            height: 150px;
            filter: blur(90px);
            opacity: 0.6;
            z-index: -1;
            border-radius: 50%;
        }

        .glow-1 {
            background: var(--primary-glow);
            top: -50px;
            left: -50px;
            animation: float 6s ease-in-out infinite alternate;
        }

        .glow-2 {
            background: var(--secondary-glow);
            bottom: -50px;
            right: -50px;
            animation: float 7s ease-in-out infinite alternate-reverse;
        }

        @keyframes float {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(30px, 30px);
            }
        }

        /* Typography */
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            margin: 0;
            background: linear-gradient(90deg, #fff, #a2acb0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            letter-spacing: 2px;
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.2rem;
            margin-top: 1rem;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 300;
            letter-spacing: 1px;
        }

        .divider {
            height: 1px;
            width: 60px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            margin: 2rem auto;
        }

        .message {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
            margin-top: 1rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: fadeIn 2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 2rem;
                width: 90%;
            }

            h1 {
                font-size: 2rem;
            }

            .message {
                font-size: 1.2rem;
            }
        }
    </style>
</head>

<body>

    <canvas id="hyperspaceCanvas"></canvas>

    <div class="container">
        <div class="glow glow-1"></div>
        <div class="glow glow-2"></div>

        <h1>ETAMAX 2026</h1>
        <h1>NAKSHATRA</h1>

        <div class="divider"></div>

        <p class="subtitle">Website Under Maintenance</p>

        <div class="message">Please Try again later</div>
    </div>

    <script>
        // Hyperspace Background Logic (Ported from React Component)
        (function () {
            const canvas = document.getElementById('hyperspaceCanvas');
            const context = canvas.getContext('2d');

            // Configuration (Defaults)
            const config = {
                starTrailOpacity: 0.8, // Increased opacity trail clearing (less trail persistence) for clearer stars initially? Or lower (0.1) for long trails? 
                // User complained "cant see". Let's use 0.8 to clear faster to prevent mud?
                // React default was 0.5 which means 50% clear per frame.
                // Let's stick to 0.5 but adjust star size.
                starSpeed: 1.02,       // Slightly faster
                starColor: "#FFFFFF",
                starSize: 1.5          // Increased base size for visibility
            };

            function hexToRgb(hex) {
                const cleanedHex = hex.replace("#", "");
                const bigint = parseInt(cleanedHex, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return [r, g, b];
            }

            function randomInRange(max, min) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            const [r, g, b] = hexToRgb(config.starColor);

            // Resize handling
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            const sizeIncrement = 1.01; // Fixed as per React code logic `const sizeIncrement = 1.01` inside component
            const radians = Math.PI / 180;

            class Star {
                constructor() {
                    this.state = {
                        alpha: 0,
                        angle: 0,
                        x: 0,
                        vX: 0,
                        y: 0,
                        vY: 0,
                        size: config.starSize,
                        active: true,
                    };
                    this.reset();
                }

                reset() {
                    const angle = randomInRange(0, 360) * radians;
                    const vX = Math.cos(angle);
                    const vY = Math.sin(angle);

                    const travelled =
                        Math.random() > 0.5
                            ? Math.random() * Math.max(canvas.width, canvas.height) +
                            Math.random() * (canvas.width * 0.24)
                            : Math.random() * (canvas.width * 0.25);

                    this.state = {
                        alpha: Math.random(), // initial opacity
                        angle: randomInRange(0, 360) * radians,
                        x: Math.floor(vX * travelled) + canvas.width / 2,
                        vX: vX, // stored direction
                        y: Math.floor(vY * travelled) + canvas.height / 2,
                        vY: vY, // stored direction
                        // Recalculate component velocity based on random speed if we wanted?
                        // Here we just store unit vector components and multiply later.

                        size: config.starSize,
                        active: true,
                    };
                }
            }

            // Create stars
            const stars = new Array(400).fill(null).map(() => new Star()); // More stars

            function render() {
                // Clear with trail effect
                // If opacity is 0.5, we draw black with 0.5 alpha.
                // config.starTrailOpacity = how much TRAIL we see?
                // If trail opacity is 1.0, we see full trail?
                // If trail opacity is 0.0, we see no trail?
                // The formula was: `invertedOpacity = 1 - starTrailOpacity`
                // `fillStyle = rgba(0,0,0, invertedOpacity)`
                // If trailOpacity = 0.5 => inverted = 0.5 => fill with 0.5 black. New frame is 50% darker.
                // If trailOpacity = 0.1 => inverted = 0.9 => fill with 0.9 black. New frame is 90% darker (drastically fades old trail).
                // Let's use 0.9 trail opacity (fades very slowly?) No.
                // If I want VISIBLE stars, I should clear less? No, clear more.
                // Let's stick with 0.5 but ensure we fill the whole canvas.

                context.fillStyle = `rgba(0, 0, 0, 0.4)`; // Hardcoded a balanced value for trails
                context.fillRect(0, 0, canvas.width, canvas.height);

                for (const star of stars) {
                    const { x, y, size, vX, vY } = star.state;

                    // Compute new position
                    // In the provided code: 
                    // star.state.vX * config.starSpeed
                    // Wait, if starSpeed is 1.01, velocity increases every frame? existing logic:
                    /*
                        vX: star.state.vX * starSpeed,
                        newX = x + vX (using OLD vX? or new?)
                        The React code:
                        const newX = x + vX
                        const newY = y + vY
                        ...
                        star.state = { ... vX: star.state.vX * starSpeed ... }
                    */

                    const newX = x + vX;
                    const newY = y + vY;

                    if (
                        newX < 0 ||
                        newX > canvas.width ||
                        newY < 0 ||
                        newY > canvas.height
                    ) {
                        star.reset();
                    } else {
                        // Update state
                        // We need to ACCELERATE.
                        // starSpeed > 1 means vX grows.
                        // x changes by vX.

                        const newVX = star.state.vX * config.starSpeed;
                        const newVY = star.state.vY * config.starSpeed;
                        const newSize = size * sizeIncrement;

                        star.state = {
                            ...star.state,
                            x: newX,
                            y: newY,
                            vX: newVX,
                            vY: newVY,
                            size: newSize
                        };

                        context.strokeStyle = `rgba(${r}, ${g}, ${b}, ${star.state.alpha})`;
                        context.lineWidth = size;
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(newX, newY);
                        context.stroke();
                    }
                }

                requestAnimationFrame(render);
            }

            render();
        })();
    </script>
</body>

</html>